import * as compression from 'compression';
import * as express from 'express';
import * as fs from 'fs';
import * as http from 'http';
import {Coordinator} from './coordinator';
import {lightning} from './lndApi';
import {makeUuid} from '../shared/uuid';
import {parse} from 'cookie';
import {verifyMessage} from './lnAuth';

const app = express();
app.use(compression({threshold: 0}));
app.use(express.json());
const server = http.createServer(app);
const coordinator = new Coordinator(server, lightning);

export const adminSessionCookieName = 'admin-session';
export const deviceSessionCookieName = 'device-session';

const getCookieFromRequest =
(req: express.Request, cookieName: string): string | undefined => {
  const cookieHeader = req.headers.cookie;
  if (!cookieHeader) {
    return undefined;
  }
  const cookies = parse(cookieHeader);
  return cookies[cookieName];
};

const getAdminSessionIdFromRequest =
(req: express.Request): string | undefined => {
  return getCookieFromRequest(req, adminSessionCookieName);
};

app.get('/api/registerAdmin/:message/:signature', async (req, res) => {
  let adminSessionId = getAdminSessionIdFromRequest(req);

  if (!adminSessionId) {
    adminSessionId = makeUuid();
  }

  let lnNodePubkey;
  try {
    lnNodePubkey = await verifyMessage(
      req.params.message,
      req.params.signature
    );
  } catch (err) {
    return res.status(400).send(err);
  }

  const {isNew} = coordinator.getOrCreateAdminSession(
    adminSessionId,
    lnNodePubkey
  );

  if (isNew) {
    return res.cookie(
      adminSessionCookieName,
      adminSessionId,
      {path: '/'}
    ).send();
  } else {
    return res.status(400).send('Device is already registered!');
  }
});

// Serve all files generated by webpack.
fs.readdirSync(`${__dirname}/../client/out`).forEach((fileName) => {
  app.get(`/${fileName}`, (req, res) => {
    const fileContents =
      fs.readFileSync(`${__dirname}/../client/out/${fileName}`);
    res.type(fileName.split('.').pop() || '').send(fileContents);
  });
});

// Fall back to index.html for all other requests. This is necessary for
// SPA-style apps like ours because the index.html file contains the
// <script> tag that loads the bundle.js file, which is necessary for
// client-side routing to work. Note that this must come after the other
// routes because express will match the first route it finds.
const indexHtml = fs.readFileSync(`${__dirname}/../client/out/index.html`);
app.get('*/', (req, res) => {
  res.type('html').send(indexHtml);
});

const port = Number(process.env.PORT) || 3000;
server.listen(port, () => {
  console.log(`Listening on *:${port}`); // eslint-disable-line no-console
});
