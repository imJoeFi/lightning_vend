import * as compression from 'compression';
import * as dotenv from 'dotenv';
import * as express from 'express';
import * as fs from 'fs';
import * as http from 'http';
import {Coordinator} from './coordinator';
import {lightning} from './lndApi';
import {verifyMessage} from './lnAuth';

const app = express();
app.use(compression({threshold: 0}));
app.use(express.json());
const server = http.createServer(app);
const coordinator = new Coordinator(server, lightning);

export const userSessionCookieName = 'user-session';
export const deviceSessionCookieName = 'device-session';

dotenv.config();

app.get('/api/registerAdmin/:message/:signature', async (req, res) => {
  let lightningNodePubkey;
  try {
    lightningNodePubkey = await verifyMessage(
      req.params.message,
      req.params.signature
    );
  } catch (err) {
    return res.status(400).send(err);
  }

  const userSessionToken =
    coordinator.createUserSessionToken(lightningNodePubkey);

  return res.cookie(
    userSessionCookieName,
    userSessionToken,
    {path: '/'}
  ).send();
});

// Serve all files generated by webpack.
fs.readdirSync(`${__dirname}/../client/out`).forEach((fileName) => {
  app.get(`/${fileName}`, (req, res) => {
    const fileContents =
      fs.readFileSync(`${__dirname}/../client/out/${fileName}`);
    res.type(fileName.split('.').pop() || '').send(fileContents);
  });
});

// Fall back to index.html for all other requests. This is necessary for
// SPA-style apps like ours because the index.html file contains the
// <script> tag that loads the bundle.js file, which is necessary for
// client-side routing to work. Note that this must come after the other
// routes because express will match the first route it finds.
const indexHtml = fs.readFileSync(`${__dirname}/../client/out/index.html`);
app.get('*/', (req, res) => {
  res.type('html').send(indexHtml);
});

const port = Number(process.env.PORT) || 3000;
server.listen(port, () => {
  console.log(`Listening on *:${port}`); // eslint-disable-line no-console
});
